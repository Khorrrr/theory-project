"""
Code Formatter for ML Translation Output

This module provides code formatting and cleanup utilities for
post-processing ML model translation results.
"""

import re
import logging
from typing import Dict, List, Any, Optional
from enum import Enum

logger = logging.getLogger(__name__)

class Language(Enum):
    """Supported programming languages."""
    PYTHON = "python"
    JAVA = "java"
    JAVASCRIPT = "javascript"
    ASSEMBLY = "assembly"

class CodeFormatter:
    """
    Formats and cleans up code generated by ML translation models.
    """

    def __init__(self):
        # Language-specific formatting rules
        self.language_rules = {
            Language.PYTHON: {
                'indent_size': 4,
                'indent_char': ' ',
                'line_ending': '\n',
                'max_line_length': 88,
                'braces_style': 'python'
            },
            Language.JAVA: {
                'indent_size': 4,
                'indent_char': ' ',
                'line_ending': '\n',
                'max_line_length': 120,
                'braces_style': 'java'
            },
            Language.JAVASCRIPT: {
                'indent_size': 2,
                'indent_char': ' ',
                'line_ending': '\n',
                'max_line_length': 100,
                'braces_style': 'javascript'
            },
            Language.ASSEMBLY: {
                'indent_size': 8,
                'indent_char': ' ',
                'line_ending': '\n',
                'max_line_length': 80,
                'braces_style': 'none'
            }
        }

        # Common patterns to clean up
        self.cleanup_patterns = [
            (r'```(?:python|java|javascript|assembly|cpp|c\+\+|c)\s*\n?', ''),  # Code block markers
            (r'```\s*$', ''),  # End code block markers
            (r'^\s*//.*(?:Translation:|Translated:|Generated:).*$', ''),  # Translation markers
            (r'^\s*#\s*(?:Translation|Translated|Generated).*$', ''),  # Python comment markers
            (r'^\s*/\*\s*(?:Translation|Translated|Generated).*?\*/\s*$', ''),  # C-style comment markers
        ]

    def format_code(self, code: str, target_language: str) -> str:
        """
        Format code according to language-specific rules.

        Args:
            code: Raw code from ML model
            target_language: Target programming language

        Returns:
            str: Formatted code
        """
        if not code or not code.strip():
            return ""

        try:
            language = Language(target_language.lower())
            rules = self.language_rules[language]
        except (ValueError, KeyError):
            logger.warning(f"Unknown language: {target_language}, using default formatting")
            language = None
            rules = self.language_rules[Language.PYTHON]

        # Initial cleanup
        code = self._cleanup_code(code)

        # Language-specific formatting
        if language == Language.PYTHON:
            return self._format_python(code, rules)
        elif language == Language.JAVA:
            return self._format_java(code, rules)
        elif language == Language.JAVASCRIPT:
            return self._format_javascript(code, rules)
        elif language == Language.ASSEMBLY:
            return self._format_assembly(code, rules)
        else:
            return self._format_generic(code, rules)

    def _cleanup_code(self, code: str) -> str:
        """Perform general cleanup of ML-generated code."""
        # Apply cleanup patterns
        for pattern, replacement in self.cleanup_patterns:
            code = re.sub(pattern, replacement, code, flags=re.MULTILINE | re.IGNORECASE)

        # Remove excessive blank lines
        code = re.sub(r'\n\s*\n\s*\n+', '\n\n', code)

        # Fix common ML model artifacts
        code = self._fix_ml_artifacts(code)

        # Normalize line endings
        code = code.replace('\r\n', '\n').replace('\r', '\n')

        # Trim leading/trailing whitespace
        code = code.strip()

        return code

    def _fix_ml_artifacts(self, code: str) -> str:
        """Fix common artifacts from ML model generation."""
        # Fix incomplete statements
        lines = code.split('\n')
        fixed_lines = []

        for line in lines:
            line = line.rstrip()

            # Remove incomplete lines that are clearly ML artifacts
            if self._is_ml_artifact_line(line):
                continue

            # Fix common formatting issues
            line = self._fix_line_artifacts(line)
            fixed_lines.append(line)

        return '\n'.join(fixed_lines)

    def _is_ml_artifact_line(self, line: str) -> bool:
        """Check if a line is likely an ML generation artifact."""
        line = line.strip().lower()

        # Common artifact patterns
        artifact_patterns = [
            'here is the',
            'the following',
            'translation:',
            'generated code:',
            'above code',
            'below code',
            'in the code',
            'note that',
            'please note',
            'as you can see',
            'in summary',
            'to summarize',
            'in conclusion'
        ]

        return any(pattern in line for pattern in artifact_patterns)

    def _fix_line_artifacts(self, line: str) -> str:
        """Fix common line-level artifacts."""
        # Fix double semicolons
        line = re.sub(r';{2,}', ';', line)

        # Fix missing spaces around operators
        line = re.sub(r'([a-zA-Z0-9_])(=)([a-zA-Z0-9_])', r'\1 = \2', line)
        line = re.sub(r'([a-zA-Z0-9_])([+\-*/])([a-zA-Z0-9_])', r'\1 \2 \3', line)

        # Fix spacing around parentheses
        line = re.sub(r'(\w+)\s*\(\s*', r'\1(', line)

        return line

    def _format_python(self, code: str, rules: Dict[str, Any]) -> str:
        """Format Python code."""
        lines = code.split('\n')
        formatted_lines = []
        indent_level = 0

        for line in lines:
            if line.strip() == '':
                formatted_lines.append('')
                continue

            stripped = line.lstrip()
            current_indent = len(line) - len(stripped)

            # Dedent for closing constructs
            if stripped.startswith(('elif', 'else:', 'except', 'finally:')):
                indent_level = max(0, indent_level - 1)

            # Apply proper indentation
            formatted_line = ' ' * (indent_level * rules['indent_size']) + stripped
            formatted_lines.append(formatted_line)

            # Indent for opening constructs
            if stripped.endswith(':') and not any(stripped.startswith(prefix) for prefix in ['elif', 'else:', 'except', 'finally:']):
                indent_level += 1

        # Python-specific cleanup
        formatted_code = '\n'.join(formatted_lines)

        # Remove unnecessary semicolons
        formatted_code = re.sub(r';(\s*$)', r'\1', formatted_code)

        # Fix import statements
        formatted_code = re.sub(r'from\s+\.\s*import', 'from . import', formatted_code)

        return formatted_code

    def _format_java(self, code: str, rules: Dict[str, Any]) -> str:
        """Format Java code."""
        lines = code.split('\n')
        formatted_lines = []
        indent_level = 0

        for line in lines:
            if line.strip() == '':
                formatted_lines.append('')
                continue

            stripped = line.lstrip()
            current_indent = len(line) - len(stripped)

            # Dedent for closing braces
            if stripped.startswith('}'):
                indent_level = max(0, indent_level - 1)

            # Apply proper indentation
            formatted_line = ' ' * (indent_level * rules['indent_size']) + stripped
            formatted_lines.append(formatted_line)

            # Indent for opening braces
            if '{' in stripped:
                indent_level += stripped.count('{')

            # Dedent for closing braces on same line
            if '}' in stripped:
                indent_level -= stripped.count('}')

        formatted_code = '\n'.join(formatted_lines)

        # Java-specific cleanup
        formatted_code = re.sub(r'\{\s*\}', '{}', formatted_code)  # Empty braces
        formatted_code = re.sub(r'\s*;\s*;', ';', formatted_code)  # Double semicolons

        return formatted_code

    def _format_javascript(self, code: str, rules: Dict[str, Any]) -> str:
        """Format JavaScript code."""
        lines = code.split('\n')
        formatted_lines = []
        indent_level = 0

        for line in lines:
            if line.strip() == '':
                formatted_lines.append('')
                continue

            stripped = line.lstrip()
            current_indent = len(line) - len(stripped)

            # Dedent for closing constructs
            if stripped.startswith(('}', ')', ']')):
                indent_level = max(0, indent_level - 1)

            # Apply proper indentation
            formatted_line = ' ' * (indent_level * rules['indent_size']) + stripped
            formatted_lines.append(formatted_line)

            # Indent for opening constructs
            if any(char in stripped for char in '{[('):
                indent_level += sum(1 for char in stripped if char in '{[(')

            # Dedent for closing constructs on same line
            if any(char in stripped for char in '}]'):
                indent_level -= sum(1 for char in stripped if char in '}]')

        formatted_code = '\n'.join(formatted_lines)

        # JavaScript-specific cleanup
        formatted_code = re.sub(r'var\s+', 'const ', formatted_code)  # Prefer const
        formatted_code = re.sub(r'\s*;\s*;', ';', formatted_code)  # Double semicolons

        return formatted_code

    def _format_assembly(self, code: str, rules: Dict[str, Any]) -> str:
        """Format assembly code."""
        lines = code.split('\n')
        formatted_lines = []

        for line in lines:
            if line.strip() == '':
                formatted_lines.append('')
                continue

            stripped = line.strip()

            # Assembly formatting: instructions on one line, labels on their own line
            if ':' in stripped and not any(op in stripped for op in ['mov', 'add', 'sub', 'jmp', 'call']):
                # This looks like a label
                formatted_lines.append(stripped)
            else:
                # This looks like an instruction
                # Split into instruction and operands
                parts = stripped.split(None, 1)
                if len(parts) == 2:
                    instruction, operands = parts
                    formatted_line = f"{instruction.ljust(8)} {operands}"
                else:
                    formatted_line = stripped

                formatted_lines.append(formatted_line)

        return '\n'.join(formatted_lines)

    def _format_generic(self, code: str, rules: Dict[str, Any]) -> str:
        """Generic code formatting for unknown languages."""
        lines = code.split('\n')
        formatted_lines = []

        for line in lines:
            if line.strip() == '':
                formatted_lines.append('')
                continue

            # Basic cleanup
            formatted_line = line.strip()
            formatted_lines.append(formatted_line)

        return '\n'.join(formatted_lines)

    def format_line_length(self, code: str, max_length: int = None) -> str:
        """Format code to respect maximum line length."""
        if max_length is None:
            max_length = 120

        lines = code.split('\n')
        formatted_lines = []

        for line in lines:
            if len(line) <= max_length:
                formatted_lines.append(line)
            else:
                # Try to break at logical points
                # This is a simplified implementation
                break_points = [',', ' ', '+', '-', '*', '/', '=', '(', ')']
                best_break = -1

                for i in range(max_length - 1, max_length // 2, -1):
                    if line[i] in break_points:
                        best_break = i + 1
                        break

                if best_break > 0:
                    formatted_lines.append(line[:best_break].rstrip())
                    # Recursively format the remainder
                    remainder = self.format_line_length(line[best_break:].strip(), max_length)
                    formatted_lines.extend(remainder.split('\n'))
                else:
                    # Force break if no good break point
                    formatted_lines.append(line[:max_length])
                    formatted_lines.append('    ' + line[max_length:])

        return '\n'.join(formatted_lines)

    def add_header_comment(self, code: str, language: str, source_info: Optional[Dict[str, Any]] = None) -> str:
        """Add a header comment with metadata about the translation."""
        language_names = {
            'python': 'Python',
            'java': 'Java',
            'javascript': 'JavaScript',
            'assembly': 'Assembly'
        }

        lang_name = language_names.get(language.lower(), language.title())

        if language.lower() == 'python':
            comment_char = '#'
        elif language.lower() in ['java', 'javascript', 'assembly']:
            comment_char = '//'
        else:
            comment_char = '//'

        header_lines = [
            f"{comment_char} Generated by ML Code Translator",
            f"{comment_char} Target Language: {lang_name}",
        ]

        if source_info:
            if 'confidence' in source_info:
                header_lines.append(f"{comment_char} Translation Confidence: {source_info['confidence']:.2f}")
            if 'model_used' in source_info:
                header_lines.append(f"{comment_char} Model: {source_info['model_used']}")

        header_lines.append(f"{comment_char}")

        header = '\n'.join(header_lines)
        return f"{header}\n{code}"

    def validate_formatting(self, code: str, language: str) -> Dict[str, Any]:
        """Validate the formatting of the generated code."""
        validation = {
            'is_valid': True,
            'warnings': [],
            'suggestions': []
        }

        lines = code.split('\n')

        # Check for common formatting issues
        for i, line in enumerate(lines, 1):
            # Check for trailing whitespace
            if line.endswith(' '):
                validation['warnings'].append(f"Line {i}: Trailing whitespace")

            # Check for tabs vs spaces inconsistency
            if '\t' in line and '    ' in code:
                validation['warnings'].append("Mixed tabs and spaces detected")

            # Check for very long lines
            if len(line) > 150:
                validation['suggestions'].append(f"Line {i}: Very long line ({len(line)} characters)")

        # Language-specific checks
        if language.lower() == 'python':
            if any(line.startswith(' ') and not line.startswith('    ') for line in lines):
                validation['warnings'].append("Inconsistent indentation detected (not 4 spaces)")

        return validation